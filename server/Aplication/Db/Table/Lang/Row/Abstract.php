<?php
abstract class Db_Table_Lang_Row_Abstract extends Db_Table_Row_Abstract
{	
#---------------------------------------------------------------------------------------------------------

	public function __construct(array $config = array())
	{
		parent::__construct($config);
	}

#---------------------------------------------------------------------------------------------------------

	public function __set($columnName, $value)
	{
		if (in_array($columnName, $this->_getTable()->getLangFields())) {
			if (null === $this->getLanguage()) {
				throw new System_Exception('Nie został ustawiony język wprowadzanych danych.');
			}
		}
		parent::__set($columnName, $value);
	}

#---------------------------------------------------------------------------------------------------------

	public function setLanguage($language)
	{
		$this->_getTable()->setLanguage($language);
	}

#---------------------------------------------------------------------------------------------------------

	public function getLanguage()
	{
		return $this->_getTable()->getLanguage();
	}

#---------------------------------------------------------------------------------------------------------

	protected function _doInsert()
	{
		if (get_parent_class($this->_getTable()) !== 'Db_Table_Lang_Abstract') {
			throw new System_Exception('Klasa tabeli nie jest rozszeszeniem instacji Db_Table_Lang_Abstract');
		}

		/**
		 * A read-only row cannot be saved.
		 */
		if ($this->_readOnly === true) {
			require_once 'Zend/Db/Table/Row/Exception.php';
			throw new Zend_Db_Table_Row_Exception('This row has been marked read-only');
		}

		/**
		 * Run pre-INSERT logic
		 */
		$this->_insert();

		$diffData = array_intersect_key($this->_data, $this->_modifiedFields);

		/**
		 * pobranie pól językowych
		 */
		$langData = array();
		$langFields = $this->_getTable()->getLangFields();
		for ($i=0, $ln=count($langFields); $i<$ln; $i++) {
			if (key_exists($langFields[$i], $diffData)) {
				$langData[$langFields[$i]] = $diffData[$langFields[$i]];
			}
		}
		if (count($langData) > 0) {
			$langData['language'] = $this->_getTable()->getLanguage();
		}

		/**
		 * Execute the INSERT (this may throw an exception)
		 */

		$data = array(
			'row' => $diffData,
			'row_lang' => $langData
		);
		//$data['row_data'] = array_intersect_key($this->_data, $this->_modifiedFields);
		//$data['other_data'] = $this->_mData;
		$primaryKey = $this->_getTable()->insert($data);

		/**
		 * Normalize the result to an array indexed by primary key column(s).
		 * The table insert() method may return a scalar.
		 */
		if (is_array($primaryKey)) {
			$newPrimaryKey = $primaryKey;
		} else {
			//ZF-6167 Use tempPrimaryKey temporary to avoid that zend encoding fails.
			$tempPrimaryKey = (array) $this->_primary;
			$newPrimaryKey = array(current($tempPrimaryKey) => $primaryKey);
		}

		/**
		 * Save the new primary key value in _data.  The primary key may have
		 * been generated by a sequence or auto-increment mechanism, and this
		 * merge should be done before the _postInsert() method is run, so the
		 * new values are available for logging, etc.
		 */
		$this->_data = array_merge($this->_data, $newPrimaryKey);

		/**
		 * Run post-INSERT logic
		 */
		$this->_postInsert();

		/**
		 * Update the _cleanData to reflect that the data has been inserted.
		 */
		$this->_refresh();

		return $primaryKey;
	}

#---------------------------------------------------------------------------------------------------------

	protected function _doUpdate()
	{
		//get_class()
		if (get_parent_class($this->_getTable()) !== 'Db_Table_Lang_Abstract') {
			throw new System_Exception('Klasa '.get_class($this->_getTable()).' nie jest rozszeszeniem klasy Db_Table_Lang_Abstract');
		}

		/**
		 * A read-only row cannot be saved.
		 */
		if ($this->_readOnly === true) {
			require_once 'Zend/Db/Table/Row/Exception.php';
			throw new Zend_Db_Table_Row_Exception('This row has been marked read-only');
		}

		/**
		 * Get expressions for a WHERE clause
		 * based on the primary key value(s).
		 */
		$where = $this->_getWhereQuery(false);

		/**
		 * Run pre-UPDATE logic
		 */
		$this->_update();

		/**
		 * Compare the data to the modified fields array to discover
		 * which columns have been changed.
		 */
		$diffData = array_intersect_key($this->_data, $this->_modifiedFields);

		/**
		 * pobranie pól językowych
		 */

		$langData = array();
		$langFields = $this->_getTable()->getLangFields();
		for ($i=0, $ln=count($langFields); $i<$ln; $i++) {
			if (key_exists($langFields[$i], $this->_data)) {
				$langData[$langFields[$i]] = $this->_data[$langFields[$i]];
				if ($this->_getTable()->getLanguage() != Module_Language_Model_Language_Mapper::getDefaultSiteLanguage()->code) {
					unset($diffData[$langFields[$i]]);
				}
			}
		}
		if (count($langData) > 0) {
			$langData['id'] = $this->_data['id'];
			$langData['language'] = $this->_getTable()->getLanguage();
		}

		//Zend_Debug::dump(array($this->_data, $this->_modifiedFields, $diffData, $langFields, $langData));
		//exit;

		/**
		 * Were any of the changed columns part of the primary key?
		 */
		$pkDiffData = array_intersect_key($diffData, array_flip((array)$this->_primary));

		/**
		 * Execute cascading updates against dependent tables.
		 * Do this only if primary key value(s) were changed.
		 */
		if (count($pkDiffData) > 0) {
			$depTables = $this->_getTable()->getDependentTables();
			if (!empty($depTables)) {
				$pkNew = $this->_getPrimaryKey(true);
				$pkOld = $this->_getPrimaryKey(false);
				foreach ($depTables as $tableClass) {
					$t = $this->_getTableFromString($tableClass);
					$t->_cascadeUpdate($this->getTableClass(), $pkOld, $pkNew);
				}
			}
		}

		/**
		 * Execute the UPDATE (this may throw an exception)
		 * Do this only if data values were changed.
		 * Use the $diffData variable, so the UPDATE statement
		 * includes SET terms only for data values that changed.
		 */
		if (count($diffData) > 0 || count($langData) > 0) {
			$data = array(
				'row' => $diffData,
				'row_lang' => $langData
			);
			$where = array(
				'row' => $where,
				'row_lang' => 
					"`" . $this->_getTable()->getLanguageTable() . "`.`id` = {$this->_data['id']} AND `" . $this->_getTable()->getLanguageTable() . '`.`language` = "' . $this->_getTable()->getLanguage() . '"'
			);
			$this->_getTable()->update($data, $where);
		}

		/**
		 * Run post-UPDATE logic.  Do this before the _refresh()
		 * so the _postUpdate() function can tell the difference
		 * between changed data and clean (pre-changed) data.
		 */
		$this->_postUpdate();

		/**
		 * Refresh the data just in case triggers in the RDBMS changed
		 * any columns.  Also this resets the _cleanData.
		 */
		$this->_refresh();

		/**
		 * Return the primary key value(s) as an array
		 * if the key is compound or a scalar if the key
		 * is a scalar.
		 */
		$primaryKey = $this->_getPrimaryKey(true);
		if (count($primaryKey) == 1) {
			return current($primaryKey);
		}

		return $primaryKey;
	}

#---------------------------------------------------------------------------------------------------------
}